{
    "objects": [
        {
            "version": "0", 
            "data": "// Version: 2.1\n\n/*\n * Default Candlepin rule set.\n *\n * Minor version number bumped on every content change. Major version bumped\n * when the API between the engine and these rules changes.\n */\n\n\n\nvar SOCKET_FACT=\"cpu.cpu_socket(s)\";\nvar RAM_FACT = \"memory.memtotal\";\n\nfunction entitlement_name_space() {\n    return Entitlement;\n}\n\nfunction compliance_name_space() {\n    return Compliance;\n}\n\nfunction autobind_name_space() {\n    return Autobind;\n}\n\n\n\n/*\n * Model object related functions.\n */\n\nfunction createPool(pool) {\n\n    pool.product_list = [];\n\n    // General function to look for an attribute in the specified\n    // attribute collection.\n    pool.findAttributeIn = function (attrName, attrs) {\n        for (var k = 0; k < attrs.length; k++) {\n            var attr = attrs[k];\n            if (attrName == attr.name) {\n                return attr.value;\n            }\n        }\n        return null;\n    }\n\n    pool.getAttribute = function (attrName) {\n        return this.findAttributeIn(attrName, this.attributes);\n    }\n\n    pool.getProductAttribute = function (attrName) {\n        return this.findAttributeIn(attrName, this.productAttributes);\n    }\n\n    // Add some functions onto pool objects:\n    pool.provides = function (productId) {\n        if (this.productId == productId) {\n            return true;\n        }\n        for (var k = 0; k < this.providedProducts.length; k++) {\n            var provided = this.providedProducts[k];\n\n            if (provided.productId == productId) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    pool.products = function () {\n        if (this.product_list == 0) {\n            this.product_list.push(this.productId);\n            for (var k = 0; k < this.providedProducts.length; k++) {\n                this.product_list.push(this.providedProducts[k].productId);\n            }\n        }\n        return this.product_list;\n    };\n    return pool;\n}\n\n\n\n/* Utility functions */\nfunction contains(a, obj) {\n    for (var i = 0; i < a.length; i++) {\n        var result = a[i] == obj;\n        if (result) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction containsAll(a, b) {\n    for (var i = 0 ; i < b.length ; i++) {\n        if (!contains(a, b[i])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction getRelevantProvidedProducts(pool, productIds) {\n    var provided = [];\n\n    for (var i = 0 ; i < productIds.length ; i++) {\n        var productId = productIds[i];\n        if (pool.provides(productId)) {\n            provided.push(productId);\n        }\n    }\n\n    return provided;\n}\n\nfunction providesSameProducts(products1, products2) {\n    return containsAll(products1, products2) && containsAll(products2, products1);\n}\n\nfunction arrayToString(a) {\n    msg = \"[\";\n    for (var j = 0; j < a.length; j++) {\n        var q = a[j];\n\n        msg += q.getId() + \" \";\n    }\n    msg += \"]\";\n    return msg;\n}\n\n// Compute the set of all sets of combinations of elements in a.\nfunction powerSet(a, n) {\n    if (a.length == 0) {\n        return [];\n    }\n\n    var res = [];\n    var tempSet = powerSet(a.slice(1), n);\n    for (var j = 0; j < tempSet.length; j++) {\n        var x = tempSet[j];\n\n        if (x.length <= n) {\n            res.push(x);\n        }\n        if (x.length + 1 <= n) {\n            var z = x.slice(0);\n            z.push(a[0]);\n            res.push(z);\n        }\n    }\n    res.push([a[0]]);\n    return res;\n}\n\n\n// Check if the provided list of pools contains any duplicated products\n// We don't need to worry about checking multi-entitle allowed products,\n// as you can use as many of those as you want.\nfunction hasNoProductOverlap(combination) {\n    var seen_product_ids = [];\n    for (var j = 0; j < combination.length; j++) {\n        var pool_class = combination[j];\n\n        var pool = pool_class[0];\n        var products = pool.products();\n        for (var i = 0 ; i < products.length ; i++) {\n            var productId = products[i];\n            log.debug(\"product overlap: \" + productId);\n            if (!contains(seen_product_ids, productId)) {\n                seen_product_ids.push(productId);\n            } else if (pool.getProductAttribute(\"multi-entitlement\") != \"yes\") {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n//Check to see if a pool provides any products that are already compliant\nfunction hasNoInstalledOverlap(pool, compliance) {\n    var products = pool.products();\n    for (var i = 0 ; i < products.length ; i++) {\n        var productId = products[i];\n        log.debug(\"installed overlap: \" + productId);\n        if (pool.getProductAttribute(\"multi-entitlement\") != \"yes\" &&\n            Object.hasOwnProperty(compliance.compliantProducts, productId)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction architectureMatches(productArchStr, consumerUnameMachine, consumerType,\n    prodAttrSeparator) {\n    // Non-system consumers without an architecture fact can pass this rule\n    // regardless what arch the product requires.\n    if (!consumerUnameMachine && \"system\" != consumerType) {\n        return true;\n    }\n\n    var supportedArches = [];\n    if (productArchStr != null) {\n        supportedArches = productArchStr.toUpperCase().split(prodAttrSeparator);\n\n        // If X86 is supported, add all variants to this list:\n        if (Utils.inArray(supportedArches, \"X86\")) {\n           supportedArches.push(\"I386\");\n           supportedArches.push(\"I586\");\n           supportedArches.push(\"I686\");\n        }\n\n        if(!Utils.inArray(supportedArches, 'ALL') && (!consumerUnameMachine ||\n           !Utils.inArray(supportedArches, consumerUnameMachine.toUpperCase()))) {\n           return false;\n       }\n   }\n\n   return true;\n}\n\n// get the number of sockets that each entitlement from a pool covers.\n// if sockets is set to 0 or is not set, it is considered to be unlimited.\n//\nfunction get_pool_sockets(pool) {\n    for (var j = 0; j < pool.productAttributes.length; j++) {\n        var prodAttr = pool.productAttributes[j];\n\n        if (prodAttr.name == \"sockets\") {\n            var sockets = prodAttr.value;\n            // TODO: is this 0 right? We would have a string here...\n            if (sockets == 0) {\n                return Infinity;\n            }\n            else {\n                return parseInt(sockets);\n            }\n        }\n    }\n    return Infinity;\n}\n\n\n// assumptions: number of pools consumed from is not considered, so we might not be taking from the smallest amount.\n// we only stack within the same pool_class. if you have stacks that provide different sets of products,\n// you won't be able to stack from them\n//\n// iterate over a pool class, and determine the quantity of entitlements needed\n// to satisfy any stacking on the pools in the class, for the given consumer\n//\n// If we find a pool that has no stacking requirements, just use that one\n// (as we'll only need a quantity of one)\n// otherwise, group the pools by stack id, then select the pools we wish to use\n// based on which grouping will come closest to fully stacking.\n//\n//\nfunction findStackingPools(pool_class, consumer, compliance) {\n    var consumer_sockets = 1;\n    if (consumer.facts[SOCKET_FACT]) {\n        consumer_sockets = consumer.facts[SOCKET_FACT];\n     }\n\n    var stackToEntitledSockets = {};\n    var stackToPoolMap = {};\n    var notStackable = [];\n\n    // data for existing partial stacks\n    // we need a map of product id to stack id\n    // (to see if there is an existing stack for a product\n    // we can build upon, or a conflicting stack)\n    var productIdToStackId = {};\n    var partialStacks = compliance.partialStacks;\n    var stack_ids = Object.getOwnPropertyNames(partialStacks);\n\n    // going to assume one stack per product on the system\n    for (var j = 0; j < stack_ids.length; j++) {\n        var stack_id = stack_ids[j];\n        log.debug(\"stack_id: \" + stack_id);\n\n        var covered_sockets = 0;\n        var entitlements = partialStacks[stack_id];\n        for (var k = 0; k < entitlements.length; k++) {\n            var entitlement = entitlements[k];\n\n            covered_sockets += entitlement.quantity * get_pool_sockets(entitlement.pool);\n            productIdToStackId[entitlement.pool.productId] = stack_id;\n            for (var m = 0; m < entitlement.pool.providedProducts.length; m++) {\n                var product = entitlement.pool.providedProducts[m];\n\n                productIdToStackId[product.productId] = stack_id;\n            }\n        }\n        // we can start entitling from the partial stack\n        stackToEntitledSockets[stack_id] = covered_sockets;\n    }\n\n    for (var j = 0; j < pool_class.length; j++) {\n        var pool = pool_class[j];\n\n        var quantity = 0;\n        // ignore any pools that clash with installed compliant products\n        if (!hasNoInstalledOverlap(pool, compliance)) {\n            log.debug(\"installed overlap found, skipping: \" + pool.getId());\n            continue;\n        }\n\n        if (pool.getProductAttribute(\"multi-entitlement\") && pool.getProductAttribute(\"stacking_id\")) {\n\n            // make sure there isn't a conflicting pool already on the system\n            var installed_stack_id;\n            var seen_stack_id = false;\n            var conflicting_stacks = false;\n            var products = pool.products();\n            for (var m = 0; m < products.length; m++) {\n                var productId = products[m];\n\n                if (productIdToStackId.hasOwnProperty(productId)) {\n                    var new_installed_stack_id = productIdToStackId[productId];\n                    if (new_installed_stack_id != installed_stack_id) {\n                        // the first id will be different\n                        if (!seen_stack_id) {\n                            installed_stack_id = new_installed_stack_id;\n                            seen_stack_id = true;\n                        } else {\n                            conflicting_stacks = true;\n                        }\n                    }\n                }\n            }\n\n            // this pool provides 2 or more products that already have entitlements on the system,\n            // with multiple stack ids\n            if (conflicting_stacks) {\n                continue;\n            }\n\n            var stack_id = pool.getProductAttribute(\"stacking_id\");\n            // check if this pool matches the stack id of an existing partial stack\n            if (seen_stack_id && installed_stack_id != stack_id) {\n                continue;\n            }\n\n\n            if (!stackToPoolMap.hasOwnProperty(stack_id)) {\n                stackToPoolMap[stack_id] = Utils.getJsMap();\n\n                // we might already have the partial stack from compliance\n                if (!stackToEntitledSockets.hasOwnProperty(stack_id)) {\n                    stackToEntitledSockets[stack_id] = 0;\n                }\n            }\n\n            // if this stack is already done, no need to add more to it.\n            if (stackToEntitledSockets[stack_id] >= consumer_sockets) {\n                continue;\n            }\n\n            var product_sockets = 0;\n            var pool_sockets = get_pool_sockets(pool);\n\n            while (stackToEntitledSockets[stack_id] + product_sockets < consumer_sockets) {\n                product_sockets += pool_sockets;\n                quantity++;\n            }\n\n            // don't take more entitlements than are available!\n            if (quantity > pool.quantity - pool.consumed) {\n                quantity = pool.quantity - pool.consumed;\n            }\n\n            stackToEntitledSockets[stack_id] += quantity * pool_sockets;\n\n            stackToPoolMap[stack_id].put(pool.id, quantity);\n        } else {\n            // not stackable, just take one.\n            notStackable.push(pool);\n        }\n\n    }\n\n    var found_pool = false;\n\n    var not_stacked_sockets = 0;\n    var not_stacked_pool_map = Utils.getJsMap();\n    // We have a not stackable pool.\n    if (notStackable.length > 0) {\n        for (var k = 0; k < notStackable.length; k++) {\n            var pool = notStackable[k];\n\n            var covered_sockets = get_pool_sockets(pool);\n            if (covered_sockets > not_stacked_sockets) {\n                found_pool = true;\n                not_stacked_pool_map = Utils.getJsMap();\n                not_stacked_pool_map.put(pool.id, 1);\n                not_stacked_sockets = covered_sockets;\n            }\n        }\n    }\n\n    not_stacked_pool_map.dump(\"not_stacked_pool_map\");\n\n    // if an unstacked pool can cover all our products, take that.\n    if (not_stacked_sockets >= consumer_sockets) {\n        return not_stacked_pool_map;\n    }\n\n    // loop over our potential stacks, and just take the first stack that covers all sockets.\n    // else take the stack that covers the most sockets.\n    var best_sockets = 0;\n    var best_stack;\n    for (stack_id in stackToPoolMap) {\n        found_pool = true;\n        if (stackToEntitledSockets[stack_id] >= consumer_sockets) {\n            return stackToPoolMap[stack_id];\n        }\n        else if (stackToEntitledSockets[stack_id] > best_sockets) {\n            best_stack = stack_id;\n            best_sockets = stackToEntitledSockets[stack_id];\n        }\n    }\n\n    // All possible pools may have overlapped with existing products\n    // so return nothing!\n    if (!found_pool) {\n        return Utils.getJsMap();\n    }\n\n    // we can't fully cover the product. either select the best non stacker, or the best stacker.\n    if (not_stacked_sockets >= best_sockets) {\n        return not_stacked_pool_map;\n    }\n    else {\n        return stackToPoolMap[best_stack];\n    }\n}\n\n\n// given 2 pools, select the best one. It is a assumed that the pools offer the\n// same selection of products.\n// returns true if pool1 is a better choice than pool2, else false\nfunction comparePools(pool1, pool2) {\n\n    // Prefer a virt_only pool over a regular pool, else fall through to the next rules.\n    // At this point virt_only pools will have already been filtered out by the pre rules\n    // for non virt machines.\n    if (pool1.getProductAttribute(\"virt_only\") == \"true\" && pool2.getProductAttribute(\"virt_only\") != \"true\") {\n        return true;\n    }\n    else if (pool2.getProductAttribute(\"virt_only\") == \"true\" && pool1.getProductAttribute(\"virt_only\") != \"true\") {\n        return false;\n    }\n\n    // If both virt_only, prefer one with host_requires, otherwise keep looking\n    // for a reason to pick one or the other. We know that the host must match\n    // as pools are filtered before even being passed to select best pools.\n    if (pool1.getProductAttribute(\"virt_only\") == \"true\" && pool2.getProductAttribute(\"virt_only\") == \"true\") {\n        if (pool1.getProductAttribute(\"requires_host\") != null && pool2.getProductAttribute(\"requires_host\") == null) {\n            return true;\n        }\n        if (pool2.getProductAttribute(\"requires_host\") != null && pool1.getProductAttribute(\"requires_host\") == null) {\n            return false;\n        }\n        // If neither condition is true, no preference...\n    }\n\n    // If two pools are still considered equal, select the pool that expires first\n    if (pool2.endDate > pool1.endDate) {\n        return true;\n    }\n\n}\n\nfunction isLevelExempt (level, exemptList) {\n    for (var j = 0; j < exemptList.length; j++) {\n        var exemptLevel = exemptList[j];\n\n        if (Utils.equalsIgnoreCase(exemptLevel, level)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvar Entitlement = {\n\n    // defines mapping of product attributes to functions\n    // the format is: <function name>:<order number>:<attr1>:...:<attrn>, comma-separated ex.:\n    // func1:1:attr1:attr2:attr3, func2:2:attr3:attr4\n    attribute_mappings: function() {\n        return  \"architecture:1:arch,\" +\n            \"sockets:1:sockets,\" +\n            \"ram:1:ram,\" +\n            \"requires_consumer_type:1:requires_consumer_type,\" +\n            \"user_license:1:user_license,\" +\n            \"virt_only:1:virt_only,\" +\n            \"virt_limit:1:virt_limit,\" +\n            \"requires_host:1:requires_host\";\n    },\n\n    ValidationResult: function () {\n        var result = {\n            errors: [],\n            warnings: [],\n\n            addWarning: function(message) {\n               this.warnings.push(message);\n            },\n\n            addError: function(message) {\n               this.errors.push(message);\n            }\n        };\n\n        return result;\n    },\n\n    get_attribute_context: function() {\n        context = JSON.parse(json_context);\n\n        if (\"pool\" in context) {\n            context.pool = createPool(context.pool);\n        }\n\n        context.hasEntitlement = function(poolId) {\n            for (var k = 0; k < this.consumerEntitlements.length; k++) {\n                var e = this.consumerEntitlements[k];\n                if (e.pool.id == poolId) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        // Get attribute from a pool. Pool attributes are preferred\n        // but if not found, the top level product attributes will be\n        // checked.\n        context.getAttribute = function(pool, attributeName) {\n            var attr = pool.getAttribute(attributeName);\n            if (!attr) {\n                attr = pool.getProductAttribute(attributeName);\n            }\n            return attr;\n        }\n\n        return context;\n    },\n\n    pre_virt_only: function() {\n        var result = Entitlement.ValidationResult();\n        context = Entitlement.get_attribute_context();\n\n        var virt_pool = Utils.equalsIgnoreCase('true', context.getAttribute(context.pool, 'virt_only'));\n        var guest = false;\n        if (context.consumer.facts['virt.is_guest']) {\n            guest = Utils.equalsIgnoreCase('true', context.consumer.facts['virt.is_guest']);\n        }\n\n        if (virt_pool && !guest) {\n            result.addError(\"rulefailed.virt.only\");\n        }\n        return JSON.stringify(result);\n    },\n\n    pre_requires_host: function() {\n        var result = Entitlement.ValidationResult();\n        context = Entitlement.get_attribute_context();\n\n        // It shouldn't be possible to get a host restricted pool in hosted, but just in\n        // case, make sure it won't be enforced if we do.\n        if (!context.standalone) {\n            return JSON.stringify(result);\n        }\n\n        if (!context.consumer.facts[\"virt.uuid\"]) {\n            result.addError(\"rulefailed.virt.only\");\n            return JSON.stringify(result);\n        }\n\n        if (!context.hostConsumer ||\n            context.hostConsumer.uuid != context.getAttribute(context.pool,\n                                                                   'requires_host')) {\n            result.addError(\"virt.guest.host.does.not.match.pool.owner\");\n        }\n        return JSON.stringify(result);\n    },\n\n    pre_requires_consumer_type: function() {\n        var result = Entitlement.ValidationResult();\n        context = Entitlement.get_attribute_context();\n\n        var requiresConsumerType = context.getAttribute(context.pool, \"requires_consumer_type\");\n        if (requiresConsumerType != null &&\n            requiresConsumerType != context.consumer.type.label &&\n            context.consumer.type.label != \"uebercert\") {\n            result.addError(\"rulefailed.consumer.type.mismatch\");\n        }\n        return JSON.stringify(result);\n    },\n\n    pre_virt_limit: function() {\n    },\n\n    pre_architecture: function() {\n        var result = Entitlement.ValidationResult();\n        context = Entitlement.get_attribute_context();\n        if (!architectureMatches(context.pool.getProductAttribute('arch'),\n                                 context.consumer.facts['uname.machine'],\n                                 context.consumer.type.label,\n                                 context.prodAttrSeparator)) {\n            result.addWarning(\"rulewarning.architecture.mismatch\");\n        }\n        return JSON.stringify(result);\n    },\n\n    pre_sockets: function() {\n        var result = Entitlement.ValidationResult();\n        context = Entitlement.get_attribute_context();\n\n        var consumer = context.consumer;\n        var pool = context.pool;\n\n        //usually, we assume socket count to be 1 if it is undef. However, we need to know if it's\n        //undef here in order to know to skip the socket comparison (per acarter/jomara)\n        if (consumer.facts[SOCKET_FACT] && !pool.getProductAttribute(\"stacking_id\")) {\n            if ((parseInt(pool.getProductAttribute(\"sockets\")) > 0) &&\n                (parseInt(pool.getProductAttribute(\"sockets\")) < parseInt(consumer.facts[SOCKET_FACT]))) {\n                result.addWarning(\"rulewarning.unsupported.number.of.sockets\");\n            }\n        }\n        return JSON.stringify(result);\n    },\n\n    pre_ram: function() {\n        var result = Entitlement.ValidationResult();\n        context = Entitlement.get_attribute_context();\n        var consumerRam = get_consumer_ram(context.consumer);\n        log.debug(\"Consumer has \" + consumerRam + \"GB of RAM.\");\n\n        var productRam = parseInt(context.pool.getProductAttribute(\"ram\"));\n        log.debug(\"Product has \" + productRam + \"GB of RAM\");\n        if (consumerRam > productRam) {\n            result.addWarning(\"rulewarning.unsupported.ram\");\n        }\n        return JSON.stringify(result);\n    },\n\n    pre_global: function() {\n        var result = Entitlement.ValidationResult();\n        context = Entitlement.get_attribute_context();\n        log.debug(\"INPUT: \" + JSON.stringify(context));\n\n        var consumer = context.consumer;\n        var pool = context.pool;\n        if (!consumer.type.manifest) {\n            var isMultiEntitlement = pool.getProductAttribute(\"multi-entitlement\");\n            if (context.hasEntitlement(pool.id) && isMultiEntitlement != \"yes\") {\n                result.addError(\"rulefailed.consumer.already.has.product\");\n            }\n\n            if (context.quantity > 1 && isMultiEntitlement != \"yes\") {\n                result.addError(\"rulefailed.pool.does.not.support.multi-entitlement\");\n            }\n\n            // If the product has no required consumer type, assume it is restricted to \"system\".\n            // \"hypervisor\"/\"uebercert\" type are essentially the same as \"system\".\n            if (!pool.getProductAttribute(\"requires_consumer_type\")) {\n                if (consumer.type.label != \"system\" && consumer.type.label != \"hypervisor\" &&\n                        consumer.type.label != \"uebercert\") {\n                    result.addError(\"rulefailed.consumer.type.mismatch\");\n                }\n\n            }\n\n            if (pool.restrictedToUsername != null && pool.restrictedToUsername != consumer.username) {\n                result.addError(\"pool.not.available.to.user, pool= '\" + pool.restrictedToUsername + \"', actual username='\" + consumer.username + \"'\" );\n            }\n        }\n\n        // Manifest consumers should not be able to find to any derived pools. Because\n        // they are exempt from all pre-rules, to keep these derived pools out of the list\n        // they can bind to we must use pre_global, which is used for manifest consumers.\n        else {\n            if (pool.getAttribute(\"pool_derived\")) {\n                result.addError(\"pool.not.available.to.manifest.consumers\");\n            }\n        }\n        return JSON.stringify(result);\n    },\n\n}\n\nvar Autobind = {\n\n    select_pools: function() {\n        // Greedy selection for now, in order\n        // XXX need to watch out for multientitle products - how so?\n\n        // An array of arrays of pools. each array is a grouping of pools that provide the\n        // same subset of products which are applicable to the requested products.\n        // further, each array is sorted, from best to worst. (pool fitness is determined\n        // arbitrarily by rules herein.\n        var context = JSON.parse(json_context);\n        var pools_by_class = [];\n\n        // \"pools\" is a list of all the owner's pools which are compatible for the system:\n        log.debug(\"Selecting best pools from: \" + context.pools.length);\n        if (log.debug) {\n            for (var m = 0; m < context.pools.length; m++) {\n                var pool = context.pools[m];\n                log.debug(\"   \" + context.pools[m].id);\n            }\n        }\n\n        log.debug(\"context.serviceLevelOverride: \" + context.serviceLevelOverride);\n        var consumerSLA = context.serviceLevelOverride;\n        if (!consumerSLA || consumerSLA.equals(\"\")) {\n            consumerSLA = context.consumer.serviceLevel;\n        }\n\n        // Builds out the pools_by_class by iterating each pool, checking which products it provides (that\n        // are relevant to this request), then filtering out other pools which provide the *exact* same products\n        // by selecting the preferred pool based on other criteria.\n        for (var i = 0 ; i < context.pools.length ; i++) {\n            var pool = createPool(context.pools[i]);\n\n            // If the SLA of the consumer does not match that of the pool\n            // we do not consider the pool unless the level is exempt\n            var poolSLA = pool.getProductAttribute('support_level');\n            var poolSLAExempt = isLevelExempt(pool.getProductAttribute('support_level'), context.exemptList);\n\n            if (!poolSLAExempt && consumerSLA &&\n                consumerSLA != \"\" && !Utils.equalsIgnoreCase(consumerSLA, poolSLA)) {\n                log.debug(\"Skipping pool \" + pool.id +\n                        \" since SLA does not match that of the consumer.\");\n                continue;\n            }\n\n            log.debug(\"Checking pool for best unique provides combination: \" +\n                    pool.id);\n            log.debug(\"  \" + pool.endDate);\n            log.debug(\"  top level product: \" + pool.productId);\n\n            var unameMachine = context.consumer.facts['uname.machine'] ?\n                context.consumer.facts['uname.machine'] : null;\n            if (architectureMatches(pool.getProductAttribute('arch'),\n                                    unameMachine,\n                                    context.consumer.type,\n                                    context.prodAttrSeparator)) {\n                var provided_products = getRelevantProvidedProducts(pool, context.products);\n                log.debug(\"  relevant provided products: \");\n                for (var n = 0; n < provided_products.length; n++) {\n                    var pp = provided_products[n];\n                    log.debug(\"    \" + pp);\n                }\n                // XXX wasteful, should be a hash or something.\n                // Tracks if we found another pool previously looked at which had the exact same provided products:\n                var duplicate_found = false;\n\n                // Check current pool against previous best to see if it's better:\n                for (var n = 0; n < pools_by_class.length; n++) {\n                    var pool_class = pools_by_class[n];\n\n                    var best_pool = pool_class[0];\n                    var best_provided_products = getRelevantProvidedProducts(best_pool, context.products);\n\n                    if (providesSameProducts(provided_products, best_provided_products)) {\n                        duplicate_found = true;\n                        log.debug(\"  provides same product combo as: \" + pool.id);\n\n                        // figure out where to insert this pool in its sorted class\n                        var i = 0;\n                        for (; i < pool_class.length; i++) {\n                            if (comparePools(pool, best_pool)) {\n                                break;\n                            }\n                        }\n                        log.debug(\"  inserted into slot: \" + i);\n\n                        // now insert the pool into the middle of the array\n                        pool_class.splice(i, 0, pool);\n                        break;\n                    }\n                }\n\n                // If we did not find a duplicate pool providing the same products,\n                if (!duplicate_found) {\n                    log.debug(\"  no duplicate found\");\n                    var pool_class = [];\n                    pool_class.push(pool);\n                    pools_by_class.push(pool_class);\n                }\n            }\n        }\n\n        var candidate_combos = powerSet(pools_by_class, context.products.length);\n\n        log.debug(\"Selecting \" + context.products.length + \" products from \" + pools_by_class.length +\n                  \" pools in \" + candidate_combos.length + \" possible combinations\");\n\n        // Select the best pool combo. We prefer:\n        // -The combo that provides the most products\n        // -The combo that uses the fewest entitlements\n\n\n        var selected_pools = Utils.getJsMap();\n        var best_provided_count = 0;\n        var best_entitlements_count = 0;\n\n        for (var k = 0; k < candidate_combos.length; k++) {\n            var pool_combo = candidate_combos[k];\n\n            var provided_count = 0;\n            var unique_provided = [];\n            for (var m = 0; m < pool_combo.length; m++) {\n                var pool_class = pool_combo[m];\n\n                var pool = pool_class[0];\n                var provided_products = getRelevantProvidedProducts(pool, context.products);\n                for (var n = 0; n < provided_products.length; n++) {\n                    var provided_product = provided_products[n];\n\n                    log.debug(\"\\t\\tprovided_product \" + provided_product);\n                    if (!contains(unique_provided, provided_product)) {\n                        unique_provided.push(provided_product);\n                    }\n                }\n            }\n\n            for (var m = 0; m < unique_provided.length; m++) {\n                var product = unique_provided[m];\n                log.debug(\"unique_provided \" + product);\n            }\n\n            // number of provided products is less than our best selection. keep our current selection.\n            if (unique_provided.length < best_provided_count) {\n                continue;\n            }\n\n            // we do it after the unique provided.length check because that value is the best we can do\n            // create 'best' stacking combo here\n            // use that best combo for the following comparison\n\n            if (unique_provided.length > best_provided_count || pool_combo.length < best_entitlements_count) {\n                // XXX we'll have to do something here to ensure no product overlap after selecting the actual pool/pools from the combo\n                if (hasNoProductOverlap(pool_combo)) {\n                    var new_selection = Utils.getJsMap();\n                    var total_entitlements = 0;\n                    for (var p = 0; p < pool_combo.length; p++) {\n                        var pool_class = pool_combo[p];\n\n                        var poolMap = findStackingPools(pool_class, context.consumer, context.compliance);\n                        poolMap.dump(\"poolMap\");\n                        new_selection.putAll(poolMap);\n                        new_selection.dump(\"new_selection\");\n\n                        var quantity = 0;\n                        var values = poolMap.values();\n                        for (var v = 0; v < values.length; v++) {\n                            quantity += values[v];\n                        }\n\n                        total_entitlements += quantity;\n                    }\n\n                    // now verify that after selecting our actual pools from the pool combo,\n                    // we still have a better choice here\n                    if (new_selection.values().length > 0) {\n                        selected_pools = new_selection;\n                        best_provided_count = unique_provided.length;\n                        best_entitlements_count = total_entitlements;\n                    }\n                }\n            }\n        }\n\n        // We may not have selected pools for all products; that's ok.\n        selected_pools.dump(\"selected_pools\");\n        var output = JSON.stringify(selected_pools.map);\n        log.debug(\"OUTPUT: \" + output);\n        return output;\n    }\n}\n\nfunction is_stacked(ent) {\n    for (var j = 0; j < ent.pool.productAttributes.length; j++) {\n        var attr = ent.pool.productAttributes[j];\n\n        if (attr.name == \"stacking_id\") {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction get_consumer_ram(consumer) {\n    var consumerRam = 1;\n    if (!(typeof consumer.facts[RAM_FACT] === undefined)) {\n        var ramGb = parseInt(consumer.facts[RAM_FACT]) / 1024 / 1024;\n        consumerRam = Math.round(ramGb);\n    }\n    return consumerRam;\n}\n\n/**\n * Returns an array of product IDs the entitlement provides which are relevant\n * (installed) on the given consumer.\n */\nfunction find_relevant_pids(entitlement, consumer) {\n    provided_pids = [];\n    if (consumer.installedProducts == null) {\n        return provided_pids;\n    }\n    for (var j = 0; j < consumer.installedProducts.length; j++) {\n        var installed_prod = consumer.installedProducts[j];\n\n        var installed_pid = installed_prod.productId;\n        if (entitlement.pool.provides(installed_pid)) {\n            log.debug(\"pool provides: \" + installed_pid);\n            provided_pids.push(installed_pid);\n        }\n    }\n    return provided_pids;\n}\n\n/*\n * Namespace for determining compliance status of a consumer system on a\n * specific date.\n *\n * Compares entitlements against installed products, accounts for stacking,\n * socket and RAM usage.\n */\nvar Compliance = {\n    get_status_context: function() {\n        context = JSON.parse(json_context);\n        context.ondate = new Date(context.ondate);\n\n        // Add some methods to the various Pool objects:\n        for (var k = 0; k < ((context.entitlements) ? context.entitlements.length : 0); k++) {\n            var e = context.entitlements[k];\n            e.pool = createPool(e.pool);\n        }\n        if (\"entitlement\" in context) {\n            context.entitlement.pool = createPool(context.entitlement.pool);\n        }\n\n        return context;\n    },\n\n    get_status: function() {\n        log.debug(\"INPUT: \" + json_context);\n        var context = Compliance.get_status_context();\n        var compStatus = Compliance.getComplianceStatusOnDate(context.consumer,\n            context.entitlements, context.ondate, log);\n        var compliantUntil = context.ondate;\n        if (compStatus.isCompliant()) {\n            if (context.entitlements.length == 0) {\n                compliantUntil = null;\n            }\n            else {\n                compliantUntil = Compliance.determineCompliantUntilDate(context.consumer,\n                    context.entitlements, context.ondate, log);\n            }\n        }\n        compStatus.compliantUntil = compliantUntil;\n        var output = JSON.stringify(compStatus);\n        log.debug(\"OUTPUT: \" + output);\n        return output;\n    },\n\n    is_stack_compliant: function() {\n        var context = Compliance.get_status_context();\n        return Compliance.stack_is_compliant(context.consumer, context.stack_id,\n            context.entitlements, log);\n    },\n\n    is_ent_compliant: function () {\n        var context = Compliance.get_status_context();\n        return Compliance.ent_is_compliant(context.consumer, context.entitlement, log);\n    },\n\n    filterEntitlementsByDate: function (entitlements, date) {\n        var filtered_ents = [];\n        for (var k = 0; k < entitlements.length; k++) {\n            var ent = entitlements[k];\n\n            var startDate = new Date(ent.startDate);\n            var endDate = new Date(ent.endDate);\n            if (Utils.date_compare(startDate, date) <= 0 && Utils.date_compare(endDate, date) >= 0) {\n                filtered_ents.push(ent);\n            }\n        }\n        return filtered_ents;\n    },\n\n    getSortedEndDates: function(entitlements) {\n        var sorter = function(date1, date2) {\n            var e1End = new Date(e1.endDate);\n            var e2End = new Date(e2.endDate);\n            return Utils.date_compare(e1End, e2End);\n        };\n\n        var dates = [];\n        for (var k = 0; k < entitlements.length; k++) {\n            var ent = entitlements[k];\n\n            dates.push(new Date(ent.endDate));\n        }\n        dates.sort(function(d1, d2) { Utils.date_compare(d1, d2) });\n        return dates;\n    },\n\n    /**\n     * Checks compliance status for a consumer on a given date.\n     */\n    getComplianceStatusOnDate: function(consumer, entitlements, ondate, log) {\n        var compStatus = {\n\n            date: ondate,\n\n            // Maps partially compliant stack IDs to entitlements:\n            partialStacks: {},\n\n            // Maps partially compliant product IDs to entitlements:\n            partiallyCompliantProducts: {},\n\n            // Maps compliant product IDs to entitlements:\n            compliantProducts: {},\n\n            // List of non-compliant product IDs:\n            nonCompliantProducts: [],\n\n            /*\n             * Add entitlement to partial stack list, or create list if it does not\n             * already exist.\n             */\n            add_partial_stack: function (stack_id, entitlement) {\n                this.partialStacks[stack_id] = this.partialStacks[stack_id] || [];\n                this.partialStacks[stack_id].push(entitlement);\n            },\n\n            /*\n             * Add entitlement to partial products list, or create list if it does not\n             * already exist.\n             */\n            add_partial_product: function (product_id, entitlement) {\n                this.partiallyCompliantProducts[product_id] = this.partiallyCompliantProducts[product_id] || [];\n                this.partiallyCompliantProducts[product_id].push(entitlement);\n            },\n\n            /*\n             * Add entitlement to compliant products list, or create list if it does not\n             * already exist.\n             */\n            add_compliant_product: function (product_id, entitlement) {\n                this.compliantProducts[product_id] = this.compliantProducts[product_id] || [];\n                this.compliantProducts[product_id].push(entitlement);\n            },\n\n            /*\n             * Return boolean indicating whether the system is compliant or not.\n             */\n            isCompliant: function() {\n                return this.nonCompliantProducts.length == 0 &&\n                    Object.keys(this.partiallyCompliantProducts).length == 0;\n            }\n        };\n\n        // Track the stack IDs we've already checked to save some time:\n        // TODO: don't use java sets\n        var compliant_stack_ids = [];\n        var non_compliant_stack_ids = [];\n\n        log.debug(\"Checking compliance status for consumer: \" + consumer.uuid + \" on date: \" + ondate);\n        var entitlementsOnDate = Compliance.filterEntitlementsByDate(entitlements, ondate);\n        for (var k = 0; k < entitlementsOnDate.length; k++) {\n            var e = entitlementsOnDate[k];\n\n            log.debug(\"  checking entitlement: \" + e.id);\n            relevant_pids = find_relevant_pids(e, consumer);\n            log.debug(\"    relevant products: \" + relevant_pids);\n\n            partially_stacked = false;\n            var ent_is_stacked = is_stacked(e);\n            // If the pool is stacked, check that the stack requirements are met:\n            if (ent_is_stacked) {\n                var stack_id = e.pool.getProductAttribute(\"stacking_id\");\n                log.debug(\"    pool has stack ID: \" + stack_id);\n\n                // Shortcuts for stacks we've already checked:\n                if (Utils.inArray(non_compliant_stack_ids, stack_id)) {\n                    log.debug(\"    stack already found to be non-compliant\");\n                    partially_stacked = true;\n                    compStatus.add_partial_stack(stack_id, e);\n                }\n                else if (Utils.inArray(compliant_stack_ids, stack_id)) {\n                    log.debug(\"    stack already found to be compliant\");\n                }\n                // Otherwise check the stack and add appropriately:\n                else if(!Compliance.stack_is_compliant(consumer, stack_id, entitlements, log)) {\n                    log.debug(\"    stack is non-compliant\");\n                    partially_stacked = true;\n                    compStatus.add_partial_stack(stack_id, e);\n                    non_compliant_stack_ids.push(stack_id);\n                }\n                else {\n                    log.debug(\"    stack is compliant\");\n                    compliant_stack_ids.push(stack_id);\n                }\n            }\n\n            for (var m = 0; m < relevant_pids.length; m++) {\n                var relevant_pid = relevant_pids[m];\n\n                if (partially_stacked) {\n                    log.debug(\"   partially compliant: \" + relevant_pid);\n                    compStatus.add_partial_product(relevant_pid, e);\n                }\n                else if (!Compliance.ent_is_compliant(consumer, e, log) && !ent_is_stacked) {\n                    log.debug(\"    partially compliant (non-stacked): \" + relevant_pid);\n                    compStatus.add_partial_product(relevant_pid, e);\n                }\n                else  {\n                    log.debug(\"    fully compliant: \" + relevant_pid);\n                    compStatus.add_compliant_product(relevant_pid, e);\n                }\n            }\n        }\n\n        // Run through each partially compliant product, if we also found a\n        // regular entitlement which provides that product, then it should not be\n        // considered partially compliant as well. We do however still leave the *stack*\n        // in partial stacks list, as this should be repaired. (it could offer other\n        // products)\n        for (var partial_prod in compStatus.partiallyCompliantProducts) {\n            if (!(typeof compStatus.compliantProducts[partial_prod] === \"undefined\")) {\n                delete compStatus.partiallyCompliantProducts[partial_prod];\n            }\n        }\n\n        // Run through the consumer's installed products and see if there are any we\n        // didn't find an entitlement for along the way:\n        for (var k = 0; k < ((consumer.installedProducts) ? consumer.installedProducts.length : 0); k++) {\n            var installed_prod = consumer.installedProducts[k];\n\n            var installed_pid = installed_prod.productId;\n            // Not compliant if we didn't find any entitlements for this product:\n            if (typeof compStatus.compliantProducts[installed_pid] === \"undefined\" &&\n                    typeof compStatus.partiallyCompliantProducts[installed_pid] === \"undefined\") {\n                compStatus.nonCompliantProducts.push(installed_pid);\n            }\n        }\n        return compStatus;\n    },\n\n    /**\n     * Determine the compliant until date for a consumer based on the specified start date\n     * and entitlements.\n     */\n    determineCompliantUntilDate: function(consumer, entitlements, startDate, log) {\n        var initialEntitlements = Compliance.filterEntitlementsByDate(entitlements, startDate);\n\n        // Get all end dates from current entitlements sorted ascending.\n        var dates = Compliance.getSortedEndDates(initialEntitlements);\n\n        for (var k = 0; k < dates.length; k++) {\n            var dateToCheck = dates[k];\n\n\n            // Ignore past dates.\n            if (dateToCheck < startDate) {\n                continue;\n            }\n\n            // Need to check if we are still compliant after the end date,\n            // so we add one second.\n            dateToCheck.setSeconds(dateToCheck.getSeconds() + 1);\n\n            var compStatus = Compliance.getComplianceStatusOnDate(consumer, entitlements,\n                                                       dateToCheck, log);\n            if (!compStatus.isCompliant()) {\n                return dateToCheck;\n            }\n        }\n        return null;\n    },\n\n    /**\n     * Check the given list of entitlements to see if a stack ID is compliant for\n     * a consumer's socket count.\n     */\n    stack_is_compliant: function(consumer, stack_id, ents, log) {\n        log.debug(\"Checking stack compliance for: \" + stack_id);\n        var consumer_sockets = 1;\n        if (consumer.facts[SOCKET_FACT]) {\n            consumer_sockets = parseInt(consumer.facts[SOCKET_FACT]);\n        }\n        log.debug(\"Consumer sockets: \" + consumer_sockets);\n\n        var covered_sockets = 0;\n        for (var k = 0; k < ents.length; k++) {\n            var ent = ents[k];\n\n            if (is_stacked(ent)) {\n                var currentStackId = ent.pool.getProductAttribute(\"stacking_id\");\n                if (currentStackId == stack_id) {\n                    covered_sockets += get_pool_sockets(ent.pool) * ent.quantity;\n                    log.debug(\"Ent \" + ent.id + \" took covered sockets to: \" + covered_sockets);\n                }\n            }\n        }\n\n        return covered_sockets >= consumer_sockets;\n    },\n\n    /*\n     * Check an entitlement to see if it provides sufficent CPU sockets a consumer.\n     */\n    ent_is_compliant: function(consumer, ent, log) {\n        log.debug(\"Checking entitlement compliance: \" + ent.id);\n        var consumerSockets = 1;\n        if (!(typeof consumer.facts[SOCKET_FACT] === undefined)) {\n            consumerSockets = parseInt(consumer.facts[SOCKET_FACT]);\n        }\n        log.debug(\"  Consumer sockets found: \" + consumerSockets);\n\n        var coveredSockets = get_pool_sockets(ent.pool);\n        log.debug(\"  Sockets covered by pool: \" + coveredSockets);\n\n        if (coveredSockets < consumerSockets) {\n            log.debug(\"  Entitlement does not cover system sockets.\");\n            return false;\n        }\n\n        // Verify RAM coverage if required.\n        // Default consumer RAM to 1 GB if not defined\n        var consumerRam = get_consumer_ram(consumer);\n        log.debug(\"  Consumer RAM found: \" + consumerRam);\n\n        var poolRam = ent.pool.getProductAttribute(\"ram\");\n        log.debug(\"poolRam: \" + poolRam);\n        if (poolRam == null) {\n            log.debug(\"  No RAM attribute on pool. Skipping RAM check.\");\n        }\n        else {\n            if (!poolRam == \"\") {\n                var ram = parseInt(poolRam);\n                log.debug(\"  Pool RAM found: \" + ram)\n                if (consumerRam > ram) {\n                    return false;\n                }\n            }\n            else {\n                log.debug(\"  Pool's RAM attribute was empty. Skipping RAM check.\");\n            }\n        }\n\n        return true\n    }\n\n}\n\n\nvar Utils = {\n\n    date_compare: function(d1, d2) {\n        if (d1 - d2 > 0) {\n            return 1;\n        }\n\n        if (d1 - d2 < 0) {\n            return -1;\n        }\n\n        return 0;\n    },\n\n    /**\n     * Determines if two strings are equal, ignoring case.\n     *\n     * NOTE: null does NOT equal \"\"\n     */\n    equalsIgnoreCase: function(str1, str2) {\n        if (str1) {\n            str1 = str1.toLowerCase();\n        }\n        if (str2) {\n            str2 = str2.toLowerCase();\n        }\n\n        return str1 == str2;\n    },\n\n    /**\n    *  This is used to collect some of the operations needed on the maps\n    *  so we do not iterate through the maps in the code above:\n    *  putAll, values, isEmpty, and dump.\n    */\n    getJsMap: function() {\n        var js_map = {\n            map: {},\n\n            put: function (key, value) {\n                this.map[key] = value;\n            },\n\n            putAll: function (add_js_map) {\n                var add_map = add_js_map.map\n                for(key in add_map)\n                {\n                    this.map[key] = add_map[key];\n                }\n             },\n\n             values: function () {\n                values = [];\n                for(key in this.map)\n                {\n                    values.push(this.map[key]);\n                }\n                return values;\n             },\n\n             isEmpty: function () {\n                 for(key in this.map) {\n                     return false;\n                 }\n                 return true;\n             },\n\n             dump: function (name) {\n                if (!log.debug) { return; }\n                log.debug(\"Map name: \" + name);\n                for(key in this.map)\n                {\n                    log.debug(\"    Key: \" + key + \", value: \" + this.map[key]);\n                }\n             }\n         };\n         return js_map;\n     },\n\n    /**\n     * Checks if the given value is in the specified array\n     */\n    inArray: function(array, value) {\n        for (var idx = 0; idx < array.length; idx++) {\n            if (array[idx] == value) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"
        }
    ]
}